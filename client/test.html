<html>
<head>
<script src="processing-1.3.6.min.js"></script>
</head>
<body>
<script>

var canvas = document.getElementById("canvas"),
    context = canvas.getContext("2d");

// Assumes a blob or url as input, a collection in which keys are hues, 
// and values are arrays of images to load.
var generatePortrait = function(image, collection) {
  var imageCount = 777,
      pixelSize = 10,
      curHue, 
      curSquare, 
      chosenImage,
      curBrightness;

  canvas.toDataURL(image);

  for (var x = 0; x < canvas.height; x+=pixelSize) {
    for (var y = 0; y < canvas.width; y+=pixelSize) {
      curSquare = context.getImageData(x, y, pixelSize, pixelSize); 
      curHue = averageHue(curSquare);
      chosenImage = getClosestImage(curHue);
      context.putImageData(chosenImage, x, y);
    };
  }; 

  var averageHue = function(curSquare) {
    var index,
    count, red, blue, green;
    for (var x = 0; x < curSquare.height; x++) {
      for (var y = 0; y < curSquare.width; y++) {
        index = (y * canvasWidth + x) * 4;
        red   += curSquare[index]
        green += curSquare[index]++
        blue  += curSquare[index]++
        count++;
      }
    }
    red = Math.floor(red/count);
    green = Math.floor(green/count);
    blue = Math.floor(blue/count);

    return rgb2hsv(red, green, blue)[h];
    
  };
};

// Walks across the hue field and finds any stack.
// At present, only grabs the top image of an array.
// Should probably grab a random one.

var getClosestImage = function(hue) {
  var getClosestDistance = function(curHue, distance) {
    var distance = 0 || distance, 
    image, imageBack, imageForward;

    if (collection[curHue]) {
      return distance;
    } else {
        if (distance <= 0) hueBack = getClosestDistance(curHue-1, distance-1);          
        if (distance >= 0) hueForward = getClosestDistance(curHue+1, distance+1);
      if (Math.abs(hueBack) > Math.abs(hueForward)) {
        return hueForward;
      } else if (Math.abs(hueForward) > Math.abs(hueBack)) {
        return hueBackward; 
      } else { 
        return hueForward;
      }
    }
  }
  
  return collection[getClosestDistance(hue) + hue][0];
};


rgb2hsv = function (r,g,b) {
    var rr, gg, bb,
        r = arguments[0] / 255,
        g = arguments[1] / 255,
        b = arguments[2] / 255,
        h, s,
        v = Math.max(r, g, b),
        diff = v - Math.min(r, g, b),
        diffc = function(c){
            return (v - c) / 6 / diff + 1 / 2;
        };

    if (diff == 0) {
        h = s = 0;
    } else {
        s = diff / v;
        rr = diffc(r);
        gg = diffc(g);
        bb = diffc(b);

        if (r === v) {
            h = bb - gg;
        }else if (g === v) {
            h = (1 / 3) + rr - bb;
        }else if (b === v) {
            h = (2 / 3) + gg - rr;
        }
        if (h < 0) {
            h += 1;
        }else if (h > 1) {
            h -= 1;
        }
    }
    return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        v: Math.round(v * 100)
    };
}


</script>


</body>
</html>