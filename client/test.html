<html>
<head>
<script src="processing-1.3.6.min.js"></script>
</head>
<body>
<script>


var canvas = document.getElementById("canvas"),
    context = canvas.getContext("2d");

// Assumes a blob or url as input, a collection in which keys are hues, 
// and values are arrays of images to load.
var generatePortrait = function(image, collection) {
  var imageCount = 777,
      pixelSize = 10,
      width = 0,
      height = 0,
      curHue, 
      curSquare, 
      chosenImage,
      curBrightness;

  canvas.toDataURL(image);

  for (var x = 0; x < height; x+=pixelSize) {
    for (var y = 0; y < width; y+=pixelSize) {
      curSquare = context.getImageData(x, y, pixelSize, pixelSize); 
      curHue = averageHue(curSquare);
      chosenImage = getClosestImage(curHue);
      context.putImageData(chosenImage, x, y);
    };
  }; 

  var averageHue = function(curSquare) {
    //Just find the average Hue.
    //Go through every pixel in the curSquare
    //+= Hue, divide by total.
    //Will work for now
  };
};

// Walks across the hue field and finds any stack.
// At present, only grabs the top image of an array.
// Should probably grab a random one.

var getClosestImage = function(hue) {
  var getClosestDistance = function(curHue, distance) {
    var distance = 0 || distance, 
    image, imageBack, imageForward;

    if (collection[curHue]) {
      return distance;
    } else {
        if (distance <= 0) hueBack = getClosestDistance(curHue-1, distance-1);          
        if (distance >= 0) hueForward = getClosestDistance(curHue+1, distance+1);
      if (Math.abs(hueBack) > Math.abs(hueForward)) {
        return hueForward;
      } else if (Math.abs(hueForward) > Math.abs(hueBack)) {
        return hueBackward; 
      } else { 
        return hueForward;
      }
    }
  }
  
  return collection[getClosestDistance(hue) + hue][0];
};

</script>


</body>
</html>